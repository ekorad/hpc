#include "aes.h"

#include <thread>

unsigned char key[]={0xaf,0x25,0x88,0x22,0x99,0x72,0x4b,0x9f,0x1e,0x3d,0x0f,0x3c,0x5e,0xca,0x7b,0x4d};

unsigned char s_box[256] =
{
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};
unsigned char inv_s_box[256] =
{
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
	0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
	0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
	0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
	0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
	0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
	0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
	0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
	0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
	0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
	0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
	0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

 unsigned char output[16];
unsigned char w[4][Nb*(Nr+1)];
unsigned char Rcon=0x01;

unsigned char xtime(unsigned char byte){
	if(byte>=0x80){
		byte=(unsigned char)((byte << 1)^0x1b);
		return byte;
	}
	else return (byte<<1);
}

void RotWord(word Word){
	unsigned char t=Word[0];
	Word[0]=Word[1];
	Word[1]=Word[2];
	Word[2]=Word[3];
	Word[3]=t;	
}
void SubWord(word Word){
	Word[0]=s_box[(int)Word[0]];Word[1]=s_box[(int)Word[1]];Word[2]=s_box[(int)Word[2]];Word[3]=s_box[(int)Word[3]];
}
void KeyExpansion(){
	int i,j;	
	for(j=0;j<Nk;j++){
		for(i=0;i<4;i++){
			w[i][j]=key[i+4*j];
		}
	}
	j=Nk;
	w[0][j]=w[0][j-1];w[1][j]=w[1][j-1];w[2][j]=w[2][j-1];w[3][j]=w[3][j-1];
	word temp={w[0][j],w[1][j],w[2][j],w[3][j]};
	RotWord(temp);
	w[0][j]=temp[0];w[1][j]=temp[1];w[2][j]=temp[2];w[3][j]=temp[3];
	SubWord(temp);
	w[0][j]=temp[0];w[1][j]=temp[1];w[2][j]=temp[2];w[3][j]=temp[3];
	w[0][j]=w[0][j]^Rcon;
	w[0][j]=w[0][j]^w[0][j-Nk];w[1][j]=w[1][j]^w[1][j-Nk];w[2][j]=w[2][j]^w[2][j-Nk];w[3][j]=w[3][j]^w[3][j-Nk];
	for(j=Nk+1;j<Nb*(Nr+1);j++){
		w[0][j]=w[0][j-1];w[1][j]=w[1][j-1];w[2][j]=w[2][j-1];w[3][j]=w[3][j-1];
		if((j%((int)Nk))==0){
			Rcon=xtime(Rcon);
			word temp={w[0][j],w[1][j],w[2][j],w[3][j]};
			RotWord(temp);
			w[0][j]=temp[0];w[1][j]=temp[1];w[2][j]=temp[2];w[3][j]=temp[3];
			SubWord(temp);
			w[0][j]=temp[0];w[1][j]=temp[1];w[2][j]=temp[2];w[3][j]=temp[3];
			w[0][j]=w[0][j]^Rcon;
			w[0][j]=w[0][j]^w[0][j-Nk];w[1][j]=w[1][j]^w[1][j-Nk];w[2][j]=w[2][j]^w[2][j-Nk];w[3][j]=w[3][j]^w[3][j-Nk];
		}
		else if((j%((int)Nk))==4 && sizeof(key)==32){
			word temp={w[0][j],w[1][j],w[2][j],w[3][j]};
			SubWord(temp);
			w[0][j]=temp[0];w[1][j]=temp[1];w[2][j]=temp[2];w[3][j]=temp[3];
			w[0][j]=w[0][j]^w[0][j-Nk];w[1][j]=w[1][j]^w[1][j-Nk];w[2][j]=w[2][j]^w[2][j-Nk];w[3][j]=w[3][j]^w[3][j-Nk];
		}
		else{
			w[0][j]=w[0][j]^w[0][j-Nk];w[1][j]=w[1][j]^w[1][j-Nk];w[2][j]=w[2][j]^w[2][j-Nk];w[3][j]=w[3][j]^w[3][j-Nk];
		}
	}
}
void AddRoundKey(state State,state w){
	int i,j;
	for(i=0;i<Nb;i++){
		for(j=0;j<Nb;j++){
			State[i][j]=State[i][j]^w[i][j];
		}		
	}
}
void SubBytes(state State){
	int i,j;
	for(i=0;i<Nb;i++){
		for(j=0;j<Nb;j++){
			State[i][j]=s_box[State[i][j]];
		}		
	}	
}
void InvSubBytes(state State){
	int i,j;
	for(i=0;i<Nb;i++){
		for(j=0;j<Nb;j++){
			State[i][j]=inv_s_box[State[i][j]];
		}		
	}	
}
void ShiftRows(state State){
	int i,j;
	state temp;
	for(i=1;i<Nb;i++){
		for(j=0;j<Nb;j++){
			temp[i][j]=State[i][j];
		}		
	}
	for(i=1;i<Nb;i++){
		for(j=0;j<Nb;j++){
			State[i][j]=temp[i][(j+i)%((int)Nb)];
		}		
	}
}
void InvShiftRows(state State){
	int i,j;
	state temp;
	for(i=1;i<Nb;i++){
		for(j=0;j<Nb;j++){
			temp[i][j]=State[i][j];
		}		
	}
	for(i=1;i<Nb;i++){
		for(j=0;j<Nb;j++){
			State[i][j]=temp[i][(j+((int)Nb)-i)%((int)Nb)];
		}		
	}	
}

/*void MixColumns(state State){
	int i,j;
	state temp;
	for(i=0;i<Nb;i++)
		for(j=0;j<Nb;j++) temp[i][j]=State[i][j];
	for(j=0;j<Nb;j++){
		State[0][j]=xtime(temp[0][j])^xtime(temp[1][j])^temp[1][j]^temp[2][j]^temp[3][j];
		State[1][j]=temp[0][j]^xtime(temp[1][j])^xtime(temp[2][j])^temp[2][j]^temp[3][j];
		State[2][j]=temp[0][j]^temp[1][j]^xtime(State[2][j])^xtime(temp[3][j])^temp[3][j];		
		State[3][j]=xtime(temp[0][j])^temp[0][j]^temp[1][j]^temp[2][j]^xtime(temp[3][j]);
	
	}
}*/


void MixColumns(state State) {
	int j;
	state temp;
	memcpy(temp, State, 16);
	unsigned char *t0, *t1, *t2, *t3, *s0, *s1, *s2, *s3;
	t0 = &(temp[0][0]);
	t1 = t0 + Nb;
	t2 = t1 + Nb;
	t3 = t2 + Nb;
	s0 = &(State[0][0]);
	s1 = s0 + Nb;
	s2 = s1 + Nb;
	s3 = s2 + Nb;
	unsigned char v0, v1, v2, v3, x0, x1, x2, x3;
	for (j = 0; j < Nb; j++)
	{
		v0 = *t0;
		v1 = *t1;
		v2 = *t2;
		v3 = *t3;
		x0 = xtime(v0);
		x1 = xtime(v1);
		x2 = xtime(v2);
		x3 = xtime(v3);
		*s0 = x0 ^ x1 ^ v1 ^ v2 ^ v3;
		*s1 = v0 ^ x1 ^ x2 ^ v2 ^ v3;
		*s2 = v0 ^ v1 ^ x2 ^ x3 ^ v3;
		*s3 = x0 ^ v0 ^ v1 ^ v2 ^ x3;
		++s0; ++s1; ++s2; ++s3;
		++t0; ++t1; ++t2; ++t3;
	}
}

void InvMixColumns(state State) {
	int j;
	state temp;
	memcpy(temp, State, 16);
	unsigned char *t0, *t1, *t2, *t3, *s0, *s1, *s2, *s3;
	t0 = &(temp[0][0]);
	t1 = t0 + Nb;
	t2 = t1 + Nb;
	t3 = t2 + Nb;
	s0 = &(State[0][0]);
	s1 = s0 + Nb;
	s2 = s1 + Nb;
	s3 = s2 + Nb;
	unsigned char v0, v1, v2, v3, x1, x2, tmp;
	for (j = 0; j < Nb; j++) {
		v0 = *t0;
		v1 = *t1;
		v2 = *t2;
		v3 = *t3;
		tmp = xtime(xtime(xtime(v0 ^ v1 ^ v2 ^ v3)));
		x1 = xtime(xtime(v0 ^ v2)) ^ v1 ^ v3 ^ tmp;
		x2 = xtime(xtime(v1 ^ v3)) ^ v0 ^ v2 ^ tmp;
		*s0 = x1 ^ v2 ^ xtime(v0 ^ v1);
		*s1 = x2 ^ v3 ^ xtime(v1 ^ v2);
		*s2 = x1 ^ v0 ^ xtime(v2 ^ v3);
		*s3 = x2 ^ v1 ^ xtime(v3 ^ v0);
		++s0; ++s1; ++s2; ++s3;
		++t0; ++t1; ++t2; ++t3;
	}
}

void Cipher(unsigned char input[4*Nb], unsigned char output[4*Nb],unsigned char w[4][Nb*(Nr+1)]){
	int i,j,round;
	state State;
	for(j=0;j<Nb;j++){
		for(i=0;i<Nb;i++){
			State[i][j]=input[i+4*j];
		}
	}
	state temp;
	for(j=0;j<Nb;j++)
		for(i=0;i<Nb;i++)	temp[i][j]=w[i][j];
	AddRoundKey(State,temp);
	for(round = 1;round<Nr;round++){
		SubBytes(State);
		ShiftRows(State);
		MixColumns(State);
		for(j=0;j<Nb;j++)
			for(i=0;i<Nb;i++)	temp[i][j]=w[i][j+Nb*round];
		AddRoundKey(State,temp);
	}
	
	SubBytes(State);
	ShiftRows(State);
	for(j=0;j<Nb;j++)
			for(i=0;i<Nb;i++)	temp[i][j]=w[i][j+((int)Nb)*((int)Nr)];
	AddRoundKey(State,temp);
	for(i=0;i<Nb;i++)
		for(j=0;j<Nb;j++) output[i+4*j]=State[i][j];
}
void InvCipher(unsigned char input[4*Nb], unsigned char output[4*Nb],unsigned char w[4][Nb*(Nr+1)]){
    	int i,j,round,round_counter=1;
	state State;
	for(j=0;j<Nb;j++){
		for(i=0;i<Nb;i++){
			State[i][j]=input[i+4*j];
		}
	}
	state temp;
	for(j=0;j<Nb;j++)
		for(i=0;i<Nb;i++)	temp[i][j]=w[i][j+((int)Nr)*((int)Nb)];
	AddRoundKey(State,temp);
	for(round = Nr-1;round>0;round--){
		InvShiftRows(State);
		InvSubBytes(State);
		for(j=0;j<Nb;j++)
			for(i=0;i<Nb;i++)	temp[i][j]=w[i][j+Nb*round];
		AddRoundKey(State,temp);
		InvMixColumns(State);
		round_counter++;		
	}
	InvShiftRows(State);	
	InvSubBytes(State);
	for(j=0;j<Nb;j++)
			for(i=0;i<Nb;i++)	temp[i][j]=w[i][j];
	AddRoundKey(State,temp);
	for(j=0;j<Nb;j++)
		for(i=0;i<Nb;i++) output[i+4*j]=State[i][j];
//	printf("\nDeciphered Text\n");
//	for(i=0;i<4*Nb;i++)	printf("%2x",output[i]);
}

